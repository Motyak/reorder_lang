#!/usr/bin/env monlang

include <smallstd.mlp>
include <utils/parsing.mlp>

var consumeExtra (OUT input):{
    var extras "\n" + " " + Byte(9)
    var nth 1
    until(():{nth > len(input) || input[#nth] !in extras}, (_):{
        nth += 1
    })

    input := tern(nth > len(input), "", input[#nth..-1])
}

var peekLineNb (input):{
    len(input) >= 1 && (input[#1] in "+-" || input[#1] in '0 .. '9)
}

var consumeLineNb (OUT input):{
    len(input) >= 1 || die()

    var sign ""
    input[#1] in "+-" && {
        len(input) >= 2 || die("Invalid line number in `" + input + "`")
        input[#2] in '0 .. '9 || die("Invalid line number in `" + input + "`")
        sign := input[#1]
        input := input[#2..-1]
    }

    var nth 1
    until(():{nth > len(input) || input[#nth] !in '0 .. '9}, (_):{
        nth += 1
    })
    
    var str tern(input == "", "", input[#1..<nth])
    str <> "" || die("Invalid line number in `" + input + "`")
    input := tern(nth > len(input), "", input[#nth..-1])
    var nb parseInt(str)

    ['sign:sign, 'nb:nb]
}

var interpretLineNb (_lineNb, OUT context):{
    var sign _lineNb.sign
    var nb _lineNb.nb

    var case_sign CaseAnalysis((c):{sign == c})
    case_sign("-", {
        ;
    })

    "'+' sign or no sign"
    case_sign(_, {
        let i context.currLineNb
        var lineEnd tern(sign == "+", i, 0) + tern(context.exclusiveRange?, nb - 1, nb)
        until(():{i == lineEnd}, (_):{
            i += 1
            var line getline()

            "skip to first line number and print it"
            not(context.succeedsRange?) && i == lineEnd && {
                print(line)
            }

            "print all"
            context.succeedsRange? && {
                print(line)
            }
        })
    })
}

var handleOpenEndRange (OUT context):{
    TODO
}

var evalLineNb (OUT input, OUT context):{
    var lineNb consumeLineNb(&input)
    interpretLineNb(lineNb, &context)
}

var evalLines (OUT input, OUT context):{
    var fromRange? $false

    peekLineNb(input) && {
        evalLineNb(&input, &context)
        consumeExtra(&input)
        fromRange? := $true
    }

    peekStr(input, "..") && {
        discard(&input, 2)
        consumeExtra(&input)
        var case CaseAnalysis(Bool)

        case(peekLineNb(input), {
            context.succeedsRange? := $true
            var lineNb consumeLineNb(&input)
            consumeExtra(&input)
            peekStr(input, "[") && {
                discard(&input, 1)
                consumeExtra(&input)
                context.exclusiveRange? := $true
            }
            interpretLineNb(lineNb, &context)
            context.succeedsRange? := $false
            context.exclusiveRange? := $false
        })

        case(fromRange? == $false, {
            peekStr(input, "[") && {
                discard(&input, 1)
                consumeExtra(&input)
                context.exclusiveRange? := $true
            }
            handleOpenEndRange(&context)
        })
    }
    ;
}

var evalProgram _

var evalCommand (OUT input, OUT context):{
    var peek CaseAnalysis((c):{peekStr(input, c)})

    -- {
        peek("q", evalQueueOp(&input, &context))
        peek("Q", evalUnqueueOp(&input, &context))
        peek("s", evalStackOp(&input, &context))
        peek("S", evalUnstackOp(&input, &context))
    }

    peek(_, {
        var lines? peekLineNb(input)
        lines? ||= peekStr(input, "..") || peekStr(input, "{")
        lines? || die("Unknown operation in `" + input + "`")
        evalLines(&input, &context)
    })
    ;
}

evalProgram := (OUT input, OUT context):{
    consumeExtra(&input)
    until(():{input == ""}, (1st_it):{
        not(1st_it) && peekStr(input, ";") && {
            discard(&input, 1)
            consumeExtra(&input)
        }
        evalCommand(&input, &context)
        consumeExtra(&input)
    })
}

var prog $args[#1]
var context [
    'currLineNb => 0
    'succeedsRange? => $false
    'exclusiveRange? => $false
]

evalProgram(&prog, &context)
